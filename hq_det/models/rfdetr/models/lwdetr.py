# ------------------------------------------------------------------------
# RF-DETR
# Copyright (c) 2025 Roboflow. All Rights Reserved.
# Licensed under the Apache License, Version 2.0 [see LICENSE for details]
# ------------------------------------------------------------------------
# Modified from LW-DETR (https://github.com/Atten4Vis/LW-DETR)
# Copyright (c) 2024 Baidu. All Rights Reserved.
# ------------------------------------------------------------------------
# Modified from Conditional DETR (https://github.com/Atten4Vis/ConditionalDETR)
# Copyright (c) 2021 Microsoft. All Rights Reserved.
# ------------------------------------------------------------------------
# Modified from DETR (https://github.com/facebookresearch/detr)
# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
# ------------------------------------------------------------------------
# Modified from Deformable DETR (https://github.com/fundamentalvision/Deformable-DETR)
# Copyright (c) 2020 SenseTime. All Rights Reserved.
# ------------------------------------------------------------------------

"""
LW-DETR model and criterion classes
"""
import copy
import math
from typing import Callable
import torch
import torch.nn.functional as F
from torch import nn

from hq_det.models.rfdetr.util import box_ops
from hq_det.models.rfdetr.util.misc import (NestedTensor, nested_tensor_from_tensor_list,
                       accuracy, get_world_size,
                       is_dist_avail_and_initialized)

from hq_det.models.rfdetr.models.backbone import build_backbone
from hq_det.models.rfdetr.models.matcher import build_matcher
from hq_det.models.rfdetr.models.transformer import build_transformer

class LWDETR(nn.Module):
    """ This is the Group DETR v3 module that performs object detection """
    def __init__(self,
                 backbone,
                 transformer,
                 num_classes,
                 num_queries,
                 aux_loss=False,
                 group_detr=1,
                 two_stage=False,
                 lite_refpoint_refine=False,
                 bbox_reparam=False):
        """ Initializes the model.
        Parameters:
            backbone: torch module of the backbone to be used. See backbone.py
            transformer: torch module of the transformer architecture. See transformer.py
            num_classes: number of object classes
            num_queries: number of object queries, ie detection slot. This is the maximal number of objects
                         Conditional DETR can detect in a single image. For COCO, we recommend 100 queries.
            aux_loss: True if auxiliary decoding losses (loss at each decoder layer) are to be used.
            group_detr: Number of groups to speed detr training. Default is 1.
            lite_refpoint_refine: TODO
        """
        super().__init__()
        self.num_queries = num_queries
        self.transformer = transformer
        hidden_dim = transformer.d_model
        self.class_embed = nn.Linear(hidden_dim, num_classes)
        self.bbox_embed = MLP(hidden_dim, hidden_dim, 4, 3)

        query_dim=4
        self.refpoint_embed = nn.Embedding(num_queries * group_detr, query_dim)
        self.query_feat = nn.Embedding(num_queries * group_detr, hidden_dim)
        nn.init.constant_(self.refpoint_embed.weight.data, 0)

        self.backbone = backbone
        self.aux_loss = aux_loss
        self.group_detr = group_detr

        # iter update
        self.lite_refpoint_refine = lite_refpoint_refine
        if not self.lite_refpoint_refine:
            self.transformer.decoder.bbox_embed = self.bbox_embed
        else:
            self.transformer.decoder.bbox_embed = None

        self.bbox_reparam = bbox_reparam

        # init prior_prob setting for focal loss
        prior_prob = 0.01
        bias_value = -math.log((1 - prior_prob) / prior_prob)
        self.class_embed.bias.data = torch.ones(num_classes) * bias_value

        # init bbox_mebed
        nn.init.constant_(self.bbox_embed.layers[-1].weight.data, 0)
        nn.init.constant_(self.bbox_embed.layers[-1].bias.data, 0)

        # two_stage
        self.two_stage = two_stage
        if self.two_stage:
            self.transformer.enc_out_bbox_embed = nn.ModuleList(
                [copy.deepcopy(self.bbox_embed) for _ in range(group_detr)])
            self.transformer.enc_out_class_embed = nn.ModuleList(
                [copy.deepcopy(self.class_embed) for _ in range(group_detr)])

        self._export = False

    def reinitialize_detection_head(self, num_classes):
        # Create new classification head
        del self.class_embed
        self.add_module("class_embed", nn.Linear(self.transformer.d_model, num_classes))
        
        # Initialize with focal loss bias adjustment
        prior_prob = 0.01
        bias_value = -math.log((1 - prior_prob) / prior_prob)
        self.class_embed.bias.data = torch.ones(num_classes) * bias_value

        if self.two_stage:
            del self.transformer.enc_out_class_embed
            self.transformer.add_module("enc_out_class_embed", nn.ModuleList(
                [copy.deepcopy(self.class_embed) for _ in range(self.group_detr)]))


    def export(self):
        self._export = True
        self._forward_origin = self.forward
        self.forward = self.forward_export
        for name, m in self.named_modules():
            if hasattr(m, "export") and isinstance(m.export, Callable) and hasattr(m, "_export") and not m._export:
                m.export()

    def forward(self, samples: NestedTensor, targets=None):
        """Â The forward expects a NestedTensor, which consists of:
               - samples.tensor: batched images, of shape [batch_size x 3 x H x W]
               - samples.mask: a binary mask of shape [batch_size x H x W], containing 1 on padded pixels

            It returns a dict with the following elements:
               - "pred_logits": the classification logits (including no-object) for all queries.
                                Shape= [batch_size x num_queries x num_classes]
               - "pred_boxes": The normalized boxes coordinates for all queries, represented as
                               (center_x, center_y, width, height). These values are normalized in [0, 1],
                               relative to the size of each individual image (disregarding possible padding).
                               See PostProcess for information on how to retrieve the unnormalized bounding box.
               - "aux_outputs": Optional, only returned when auxilary losses are activated. It is a list of
                                dictionnaries containing the two above keys for each decoder layer.
        """
        if isinstance(samples, (list, torch.Tensor)):
            samples = nested_tensor_from_tensor_list(samples)
        features, poss = self.backbone(samples)

        srcs = []
        masks = []
        for l, feat in enumerate(features):
            src, mask = feat.decompose()
            srcs.append(src)
            masks.append(mask)
            assert mask is not None

        if self.training:
            refpoint_embed_weight = self.refpoint_embed.weight
            query_feat_weight = self.query_feat.weight
        else:
            # only use one group in inference
            refpoint_embed_weight = self.refpoint_embed.weight[:self.num_queries]
            query_feat_weight = self.query_feat.weight[:self.num_queries]

        hs, ref_unsigmoid, hs_enc, ref_enc = self.transformer(
            srcs, masks, poss, refpoint_embed_weight, query_feat_weight)

        if self.bbox_reparam:
            outputs_coord_delta = self.bbox_embed(hs)
            outputs_coord_cxcy = outputs_coord_delta[..., :2] * ref_unsigmoid[..., 2:] + ref_unsigmoid[..., :2]
            outputs_coord_wh = outputs_coord_delta[..., 2:].exp() * ref_unsigmoid[..., 2:]
            outputs_coord = torch.concat(
                [outputs_coord_cxcy, outputs_coord_wh], dim=-1
            )
        else:
            outputs_coord = (self.bbox_embed(hs) + ref_unsigmoid).sigmoid()

        outputs_class = self.class_embed(hs)

        out = {'pred_logits': outputs_class[-1], 'pred_boxes': outputs_coord[-1]}
        if self.aux_loss:
            out['aux_outputs'] = self._set_aux_loss(outputs_class, outputs_coord)

        if self.two_stage:
            group_detr = self.group_detr if self.training else 1
            hs_enc_list = hs_enc.chunk(group_detr, dim=1)
            cls_enc = []
            for g_idx in range(group_detr):
                cls_enc_gidx = self.transformer.enc_out_class_embed[g_idx](hs_enc_list[g_idx])
                cls_enc.append(cls_enc_gidx)
            cls_enc = torch.cat(cls_enc, dim=1)
            out['enc_outputs'] = {'pred_logits': cls_enc, 'pred_boxes': ref_enc}
        return out

    def forward_export(self, tensors):
        srcs, _, poss = self.backbone(tensors)
        # only use one group in inference
        refpoint_embed_weight = self.refpoint_embed.weight[:self.num_queries]
        query_feat_weight = self.query_feat.weight[:self.num_queries]

        hs, ref_unsigmoid, hs_enc, ref_enc = self.transformer(
            srcs, None, poss, refpoint_embed_weight, query_feat_weight)

        if self.bbox_reparam:
            outputs_coord_delta = self.bbox_embed(hs)
            outputs_coord_cxcy = outputs_coord_delta[..., :2] * ref_unsigmoid[..., 2:] + ref_unsigmoid[..., :2]
            outputs_coord_wh = outputs_coord_delta[..., 2:].exp() * ref_unsigmoid[..., 2:]
            outputs_coord = torch.concat(
                [outputs_coord_cxcy, outputs_coord_wh], dim=-1
            )
        else:
            outputs_coord = (self.bbox_embed(hs) + ref_unsigmoid).sigmoid()
        outputs_class = self.class_embed(hs)
        return outputs_coord, outputs_class

    @torch.jit.unused
    def _set_aux_loss(self, outputs_class, outputs_coord):
        # this is a workaround to make torchscript happy, as torchscript
        # doesn't support dictionary with non-homogeneous values, such
        # as a dict having both a Tensor and a list.
        return [{'pred_logits': a, 'pred_boxes': b}
                for a, b in zip(outputs_class[:-1], outputs_coord[:-1])]

    def update_drop_path(self, drop_path_rate, vit_encoder_num_layers):
        """ """
        dp_rates = [x.item() for x in torch.linspace(0, drop_path_rate, vit_encoder_num_layers)]
        for i in range(vit_encoder_num_layers):
            if hasattr(self.backbone[0].encoder, 'blocks'): # Not aimv2
                if hasattr(self.backbone[0].encoder.blocks[i].drop_path, 'drop_prob'):
                    self.backbone[0].encoder.blocks[i].drop_path.drop_prob = dp_rates[i]
            else: # aimv2
                if hasattr(self.backbone[0].encoder.trunk.blocks[i].drop_path, 'drop_prob'):
                    self.backbone[0].encoder.trunk.blocks[i].drop_path.drop_prob = dp_rates[i]

    def update_dropout(self, drop_rate):
        for module in self.transformer.modules():
            if isinstance(module, nn.Dropout):
                module.p = drop_rate


class SetCriterion(nn.Module):
    """ è¿ä¸ªç±»è®¡ç®æ¡ä»¶DETRçæå¤±å½æ°ã
    è®¡ç®è¿ç¨åä¸ºä¸¤ä¸ªæ­¥éª¤ï¼
        1) è®¡ç®çå®æ¡åæ¨¡åè¾åºä¹é´çåçå©å¹é
        2) çç£æ¯å¯¹å¹éççå®å¼/é¢æµå¼ï¼çç£ç±»å«åè¾¹çæ¡ï¼
    """
    def __init__(self,
                 num_classes,  # ç±»å«æ°éï¼ä¸åæ¬ç¹æ®çæ ç®æ ç±»å«
                 matcher,      # è½å¤è®¡ç®ç®æ åæè®®ä¹é´å¹éçæ¨¡å
                 weight_dict,  # åå«æå¤±åç§°ä½ä¸ºé®ãç¸å¯¹æéä½ä¸ºå¼çå­å¸
                 focal_alpha,  # Focal Lossä¸­çalphaåæ°
                 losses,       # è¦åºç¨çæææå¤±åè¡¨
                 group_detr=1, # å éDETRè®­ç»çç»æ°ï¼é»è®¤ä¸º1
                 sum_group_losses=False,      # æ¯å¦å¯¹ç»æå¤±æ±å
                 use_varifocal_loss=False,    # æ¯å¦ä½¿ç¨Varifocalæå¤±
                 use_position_supervised_loss=False,  # æ¯å¦ä½¿ç¨ä½ç½®çç£æå¤±
                 ia_bce_loss=False,):         # æ¯å¦ä½¿ç¨IA-BCEæå¤±
        """ åå»ºæå¤±ååã
        åæ°:
            num_classes: ç®æ ç±»å«æ°éï¼çç¥ç¹æ®çæ ç®æ ç±»å«
            matcher: è½å¤è®¡ç®ç®æ åæè®®ä¹é´å¹éçæ¨¡å
            weight_dict: åå«æå¤±åç§°ä½ä¸ºé®ãç¸å¯¹æéä½ä¸ºå¼çå­å¸
            losses: è¦åºç¨çæææå¤±åè¡¨ãåè§get_lossäºè§£å¯ç¨æå¤±åè¡¨
            focal_alpha: Focal Lossä¸­çalphaåæ°
            group_detr: å éDETRè®­ç»çç»æ°ï¼é»è®¤ä¸º1
        """
        super().__init__()
        self.num_classes = num_classes
        self.matcher = matcher
        self.weight_dict = weight_dict
        self.losses = losses
        self.focal_alpha = focal_alpha
        self.group_detr = group_detr
        self.sum_group_losses = sum_group_losses
        self.use_varifocal_loss = use_varifocal_loss
        self.use_position_supervised_loss = use_position_supervised_loss
        self.ia_bce_loss = ia_bce_loss

    def loss_labels(self, outputs, targets, indices, num_boxes, log=True):
        """åç±»æå¤±ï¼äºåfocal lossï¼
        targetså­å¸å¿é¡»åå«é®"labels"ï¼åå«ç»´åº¦ä¸º[nb_target_boxes]çå¼ é
        """
        assert 'pred_logits' in outputs
        src_logits = outputs['pred_logits']  # è·åé¢æµçlogits

        # è·åæºé¢æµçæåç´¢å¼
        idx = self._get_src_permutation_idx(indices)
        # è¿æ¥ææå¹éçç®æ ç±»å«
        target_classes_o = torch.cat([t["labels"][J] for t, (_, J) in zip(targets, indices)])

        if self.ia_bce_loss:
            # IA-BCEæå¤±ï¼åºäºIoUçèªéåºäºåäº¤åçµæå¤±
            alpha = self.focal_alpha
            gamma = 2 
            src_boxes = outputs['pred_boxes'][idx]  # è·åé¢æµæ¡
            target_boxes = torch.cat([t['boxes'][i] for t, (_, i) in zip(targets, indices)], dim=0)  # è·åç®æ æ¡

            # è®¡ç®é¢æµæ¡åç®æ æ¡ä¹é´çIoU
            iou_targets=torch.diag(box_ops.box_iou(
                box_ops.box_cxcywh_to_xyxy(src_boxes.detach()),
                box_ops.box_cxcywh_to_xyxy(target_boxes))[0])
            pos_ious = iou_targets.clone().detach()  # æ­£æ ·æ¬IoU
            prob = src_logits.sigmoid()  # é¢æµæ¦ç
            
            # åå§åæ­£æ ·æ¬æéåè´æ ·æ¬æé
            pos_weights = torch.zeros_like(src_logits)
            neg_weights =  prob ** gamma

            # æå»ºæ­£æ ·æ¬ç´¢å¼
            pos_ind=[id for id in idx]
            pos_ind.append(target_classes_o)

            # è®¡ç®èªéåºæé
            t = prob[pos_ind].pow(alpha) * pos_ious.pow(1 - alpha)
            t = torch.clamp(t, 0.01).detach()

            pos_weights[pos_ind] = t.to(pos_weights.dtype)
            neg_weights[pos_ind] = 1 - t.to(neg_weights.dtype)
            
            # ä½¿ç¨èåçlogsigmoidéæ°è¡¨è¿°æ åæå¤±ï¼æé«æ°å¼ç¨³å®æ§
            loss_ce = neg_weights * src_logits - F.logsigmoid(src_logits) * (pos_weights + neg_weights)
            loss_ce = loss_ce.sum() / num_boxes

        elif self.use_position_supervised_loss:
            # ä½ç½®çç£æå¤±ï¼åºäºIoUçä½ç½®æç¥åç±»æå¤±
            src_boxes = outputs['pred_boxes'][idx]
            target_boxes = torch.cat([t['boxes'][i] for t, (_, i) in zip(targets, indices)], dim=0)

            # è®¡ç®IoUä½ä¸ºä½ç½®çç£ä¿¡å·
            iou_targets=torch.diag(box_ops.box_iou(
                box_ops.box_cxcywh_to_xyxy(src_boxes.detach()),
                box_ops.box_cxcywh_to_xyxy(target_boxes))[0])
            pos_ious = iou_targets.clone().detach()
            pos_ious_func = pos_ious  # IoUå½æ°

            # åå»ºç±»å«IoUç®æ å¼ é
            cls_iou_func_targets = torch.zeros((src_logits.shape[0], src_logits.shape[1],self.num_classes),
                                        dtype=src_logits.dtype, device=src_logits.device)

            pos_ind=[id for id in idx]
            pos_ind.append(target_classes_o)
            cls_iou_func_targets[pos_ind] = pos_ious_func
            
            # å½ä¸åIoUç®æ 
            norm_cls_iou_func_targets = cls_iou_func_targets \
                / (cls_iou_func_targets.view(cls_iou_func_targets.shape[0], -1, 1).amax(1, True) + 1e-8)
            loss_ce = position_supervised_loss(src_logits, norm_cls_iou_func_targets, num_boxes, alpha=self.focal_alpha, gamma=2) * src_logits.shape[1]

        elif self.use_varifocal_loss:
            # Varifocalæå¤±ï¼å¯åç¦è·æå¤±
            src_boxes = outputs['pred_boxes'][idx]
            target_boxes = torch.cat([t['boxes'][i] for t, (_, i) in zip(targets, indices)], dim=0)

            # è®¡ç®IoUä½ä¸ºè´¨éææ 
            iou_targets=torch.diag(box_ops.box_iou(
                box_ops.box_cxcywh_to_xyxy(src_boxes.detach()),
                box_ops.box_cxcywh_to_xyxy(target_boxes))[0])
            pos_ious = iou_targets.clone().detach()

            # åå»ºç±»å«IoUç®æ å¼ é
            cls_iou_targets = torch.zeros((src_logits.shape[0], src_logits.shape[1],self.num_classes),
                                        dtype=src_logits.dtype, device=src_logits.device)

            pos_ind=[id for id in idx]
            pos_ind.append(target_classes_o)
            cls_iou_targets[pos_ind] = pos_ious
            loss_ce = sigmoid_varifocal_loss(src_logits, cls_iou_targets, num_boxes, alpha=self.focal_alpha, gamma=2) * src_logits.shape[1]
        else:
            # æ åFocal Loss
            # åå»ºç®æ ç±»å«å¼ éï¼é»è®¤ä¸ºæ ç®æ ç±»å«
            target_classes = torch.full(src_logits.shape[:2], self.num_classes,
                                        dtype=torch.int64, device=src_logits.device)
            target_classes[idx] = target_classes_o  # è®¾ç½®å¹éä½ç½®çç±»å«

            # åå»ºone-hotç¼ç çç®æ ç±»å«
            target_classes_onehot = torch.zeros([src_logits.shape[0], src_logits.shape[1], src_logits.shape[2]+1],
                                                dtype=src_logits.dtype, layout=src_logits.layout, device=src_logits.device)
            target_classes_onehot.scatter_(2, target_classes.unsqueeze(-1), 1)

            target_classes_onehot = target_classes_onehot[:,:,:-1]  # ç§»é¤æ ç®æ ç±»å«
            loss_ce = sigmoid_focal_loss(src_logits, target_classes_onehot, num_boxes, alpha=self.focal_alpha, gamma=2) * src_logits.shape[1]
        
        losses = {'loss_ce': loss_ce}

        if log:
            # è®¡ç®åç±»éè¯¯çï¼ä»ç¨äºæ¥å¿è®°å½ï¼
            losses['class_error'] = 100 - accuracy(src_logits[idx], target_classes_o)[0]
        return losses

    @torch.no_grad()
    def loss_cardinality(self, outputs, targets, indices, num_boxes):
        """è®¡ç®åºæ°è¯¯å·®ï¼å³é¢æµéç©ºæ¡æ°éçç»å¯¹è¯¯å·®
        è¿ä¸æ¯çæ­£çæå¤±ï¼ä»ç¨äºæ¥å¿è®°å½ç®çãä¸ä¼ æ­æ¢¯åº¦
        
        Args:
            outputs: æ¨¡åè¾åºå­å¸ï¼åå«é¢æµlogits
            targets: ç®æ åè¡¨ï¼æ¯ä¸ªåç´ åå«æ ç­¾ä¿¡æ¯
            indices: å¹éç´¢å¼
            num_boxes: ç®æ æ¡æ°é
            
        Returns:
            losses: åå«åºæ°è¯¯å·®çæå¤±å­å¸
        """
        # è·åé¢æµlogits
        pred_logits = outputs['pred_logits']
        device = pred_logits.device
        
        # è®¡ç®æ¯ä¸ªæ ·æ¬ççå®ç®æ æ¡æ°é
        tgt_lengths = torch.as_tensor([len(v["labels"]) for v in targets], device=device)
        
        # ç»è®¡é¢æµä¸ºé"æ ç®æ "ç±»å«çæ°éï¼æé¤æåä¸ä¸ªç±»å«ï¼å³èæ¯ç±»ï¼
        # argmax(-1)è·åæ¯ä¸ªé¢æµçæå¤§æ¦çç±»å«ç´¢å¼
        # æ¯è¾æ¯å¦ä¸ç­äºæåä¸ä¸ªç±»å«ï¼èæ¯ç±»ï¼
        # sum(1)å¨batchç»´åº¦ä¸æ±åï¼å¾å°æ¯ä¸ªæ ·æ¬çé¢æµç®æ æ°é
        card_pred = (pred_logits.argmax(-1) != pred_logits.shape[-1] - 1).sum(1)
        
        # è®¡ç®é¢æµæ°éä¸çå®æ°éçL1æå¤±
        card_err = F.l1_loss(card_pred.float(), tgt_lengths.float())
        losses = {'cardinality_error': card_err}
        return losses

    def loss_boxes(self, outputs, targets, indices, num_boxes):
        """è®¡ç®è¾¹çæ¡ç¸å³çæå¤±ï¼L1åå½æå¤±åGIoUæå¤±
        
        Args:
            outputs: æ¨¡åè¾åºå­å¸ï¼å¿é¡»åå«'pred_boxes'
            targets: ç®æ åè¡¨ï¼æ¯ä¸ªå­å¸å¿é¡»åå«"boxes"é®ï¼æ ¼å¼ä¸º[nb_target_boxes, 4]
            indices: å¹éç´¢å¼
            num_boxes: ç®æ æ¡æ°éï¼ç¨äºå½ä¸å
            
        Returns:
            losses: åå«è¾¹çæ¡æå¤±çå­å¸
        """
        # ç¡®ä¿è¾åºä¸­åå«é¢æµæ¡
        assert 'pred_boxes' in outputs
        
        # è·åæºé¢æµæ¡çæåç´¢å¼
        idx = self._get_src_permutation_idx(indices)
        
        # æåå¹éçé¢æµæ¡åç®æ æ¡
        src_boxes = outputs['pred_boxes'][idx]  # é¢æµçè¾¹çæ¡
        target_boxes = torch.cat([t['boxes'][i] for t, (_, i) in zip(targets, indices)], dim=0)  # çå®è¾¹çæ¡

        # è®¡ç®L1åå½æå¤±ï¼é¢æµæ¡ä¸ç®æ æ¡ä¹é´çç»å¯¹å·®å¼ï¼
        loss_bbox = F.l1_loss(src_boxes, target_boxes, reduction='none')
        losses = {}
        losses['loss_bbox'] = loss_bbox.sum() / num_boxes  # å½ä¸åL1æå¤±

        # è®¡ç®GIoUæå¤±
        # å°ä¸­å¿ç¹æ ¼å¼(cx,cy,w,h)è½¬æ¢ä¸ºè§ç¹æ ¼å¼(x1,y1,x2,y2)
        src_boxes_xyxy = box_ops.box_cxcywh_to_xyxy(src_boxes)
        target_boxes_xyxy = box_ops.box_cxcywh_to_xyxy(target_boxes)
        
        # è®¡ç®å¹¿ä¹IoUï¼åå¯¹è§çº¿åç´ ï¼å¯¹åºå¹éçæ¡å¯¹ï¼
        giou_scores = box_ops.generalized_box_iou(src_boxes_xyxy, target_boxes_xyxy)
        loss_giou = 1 - torch.diag(giou_scores)  # GIoUæå¤± = 1 - GIoUåæ°
        
        losses['loss_giou'] = loss_giou.sum() / num_boxes  # å½ä¸åGIoUæå¤±
        return losses

    def _get_src_permutation_idx(self, indices):
        """è·åæºé¢æµæ¡çæåç´¢å¼
        
        Args:
            indices: å¹éç´¢å¼åè¡¨ï¼æ¯ä¸ªåç´ ä¸º(src_idx, tgt_idx)åç»
            
        Returns:
            batch_idx: æ¹æ¬¡ç´¢å¼
            src_idx: æºé¢æµæ¡ç´¢å¼
        """
        # ä¸ºæ¯ä¸ªå¹éå¯¹åå»ºæ¹æ¬¡ç´¢å¼
        batch_idx = torch.cat([torch.full_like(src, i) for i, (src, _) in enumerate(indices)])
        # è¿æ¥æææºç´¢å¼
        src_idx = torch.cat([src for (src, _) in indices])
        return batch_idx, src_idx

    def _get_tgt_permutation_idx(self, indices):
        """è·åç®æ æ¡çæåç´¢å¼
        
        Args:
            indices: å¹éç´¢å¼åè¡¨ï¼æ¯ä¸ªåç´ ä¸º(src_idx, tgt_idx)åç»
            
        Returns:
            batch_idx: æ¹æ¬¡ç´¢å¼
            tgt_idx: ç®æ æ¡ç´¢å¼
        """
        # ä¸ºæ¯ä¸ªå¹éå¯¹åå»ºæ¹æ¬¡ç´¢å¼
        batch_idx = torch.cat([torch.full_like(tgt, i) for i, (_, tgt) in enumerate(indices)])
        # è¿æ¥ææç®æ ç´¢å¼
        tgt_idx = torch.cat([tgt for (_, tgt) in indices])
        return batch_idx, tgt_idx

    def get_loss(self, loss, outputs, targets, indices, num_boxes, **kwargs):
        """æ ¹æ®æå¤±ç±»åè°ç¨ç¸åºçæå¤±è®¡ç®å½æ°
        
        Args:
            loss: æå¤±ç±»åå­ç¬¦ä¸²
            outputs: æ¨¡åè¾åº
            targets: ç®æ æ°æ®
            indices: å¹éç´¢å¼
            num_boxes: ç®æ æ¡æ°é
            **kwargs: é¢å¤åæ°
            
        Returns:
            è®¡ç®å¾å°çæå¤±å­å¸
        """
        # æå¤±å½æ°æ å°è¡¨
        loss_map = {
            'labels': self.loss_labels,      # åç±»æå¤±
            'cardinality': self.loss_cardinality,  # åºæ°æå¤±
            'boxes': self.loss_boxes,        # è¾¹çæ¡æå¤±
        }
        assert loss in loss_map, f'do you really want to compute {loss} loss?'
        return loss_map[loss](outputs, targets, indices, num_boxes, **kwargs)

    def forward(self, outputs, targets):
        """æ§è¡æå¤±è®¡ç®çä¸»å½æ°
        
        Args:
            outputs: æ¨¡åè¾åºå­å¸ï¼åå«é¢æµç»æ
            targets: ç®æ åè¡¨ï¼é¿åº¦ç­äºbatch_size
            
        Returns:
            losses: åå«ææè®¡ç®æå¤±çå­å¸
        """
        # è®­ç»æ¶ä½¿ç¨åç»DETRï¼æ¨çæ¶ä½¿ç¨åç»
        group_detr = self.group_detr if self.training else 1
        
        # æåä¸»è¾åºï¼æé¤è¾å©è¾åºï¼
        outputs_without_aux = {k: v for k, v in outputs.items() if k != 'aux_outputs'}

        # è·åæåä¸å±è¾åºä¸ç®æ çå¹éå³ç³»
        indices = self.matcher(outputs_without_aux, targets, group_detr=group_detr)

        # è®¡ç®ææèç¹ä¸ç®æ æ¡çå¹³åæ°éï¼ç¨äºå½ä¸å
        num_boxes = sum(len(t["labels"]) for t in targets)
        if not self.sum_group_losses:
            num_boxes = num_boxes * group_detr  # å¦æä¸æ±ååç»æå¤±ï¼åä¹ä»¥ç»æ°
            
        # è½¬æ¢ä¸ºå¼ éå¹¶åæ­¥å°ææè¿ç¨
        num_boxes = torch.as_tensor([num_boxes], dtype=torch.float, device=next(iter(outputs.values())).device)
        if is_dist_avail_and_initialized():
            torch.distributed.all_reduce(num_boxes)  # åå¸å¼è®­ç»æ¶åæ­¥
        num_boxes = torch.clamp(num_boxes / get_world_size(), min=1).item()  # å¹³åå¹¶ç¡®ä¿æå°å¼ä¸º1

        # è®¡ç®ææè¯·æ±çæå¤±
        losses = {}
        for loss in self.losses:
            losses.update(self.get_loss(loss, outputs, targets, indices, num_boxes))

        # å¤çè¾å©æå¤±ï¼å¯¹æ¯ä¸ªä¸­é´å±çè¾åºéå¤æ­¤è¿ç¨
        if 'aux_outputs' in outputs:
            for i, aux_outputs in enumerate(outputs['aux_outputs']):
                # ä¸ºè¾å©è¾åºéæ°è®¡ç®å¹é
                indices = self.matcher(aux_outputs, targets, group_detr=group_detr)
                for loss in self.losses:
                    kwargs = {}
                    if loss == 'labels':
                        # ä»å¯¹æåä¸å±å¯ç¨æ¥å¿è®°å½
                        kwargs = {'log': False}
                    # è®¡ç®è¾å©æå¤±å¹¶æ·»å å±ç´¢å¼åç¼
                    l_dict = self.get_loss(loss, aux_outputs, targets, indices, num_boxes, **kwargs)
                    l_dict = {k + f'_{i}': v for k, v in l_dict.items()}
                    losses.update(l_dict)

        # å¤çç¼ç å¨è¾åºæå¤±
        if 'enc_outputs' in outputs:
            enc_outputs = outputs['enc_outputs']
            # ä¸ºç¼ç å¨è¾åºè®¡ç®å¹é
            indices = self.matcher(enc_outputs, targets, group_detr=group_detr)
            for loss in self.losses:
                kwargs = {}
                if loss == 'labels':
                    # ä»å¯¹æåä¸å±å¯ç¨æ¥å¿è®°å½
                    kwargs['log'] = False
                # è®¡ç®ç¼ç å¨æå¤±å¹¶æ·»å _encåç¼
                l_dict = self.get_loss(loss, enc_outputs, targets, indices, num_boxes, **kwargs)
                l_dict = {k + f'_enc': v for k, v in l_dict.items()}
                losses.update(l_dict)

        return losses


def sigmoid_focal_loss(inputs, targets, num_boxes, alpha: float = 0.25, gamma: float = 2):
    """
    Loss used in RetinaNet for dense detection: https://arxiv.org/abs/1708.02002.
    Args:
        inputs: A float tensor of arbitrary shape.
                The predictions for each example.
        targets: A float tensor with the same shape as inputs. Stores the binary
                 classification label for each element in inputs
                (0 for the negative class and 1 for the positive class).
        alpha: (optional) Weighting factor in range (0,1) to balance
                positive vs negative examples. Default = -1 (no weighting).
        gamma: Exponent of the modulating factor (1 - p_t) to
               balance easy vs hard examples.
    Returns:
        Loss tensor
    """
    prob = inputs.sigmoid()
    ce_loss = F.binary_cross_entropy_with_logits(inputs, targets, reduction="none")
    p_t = prob * targets + (1 - prob) * (1 - targets)
    loss = ce_loss * ((1 - p_t) ** gamma)

    if alpha >= 0:
        alpha_t = alpha * targets + (1 - alpha) * (1 - targets)
        loss = alpha_t * loss

    return loss.mean(1).sum() / num_boxes


def sigmoid_varifocal_loss(inputs, targets, num_boxes, alpha: float = 0.25, gamma: float = 2):
    prob = inputs.sigmoid()
    focal_weight = targets * (targets > 0.0).float() + \
            (1 - alpha) * (prob - targets).abs().pow(gamma) * \
            (targets <= 0.0).float()
    ce_loss = F.binary_cross_entropy_with_logits(inputs, targets, reduction="none")
    loss = ce_loss * focal_weight

    return loss.mean(1).sum() / num_boxes


def position_supervised_loss(inputs, targets, num_boxes, alpha: float = 0.25, gamma: float = 2):
    prob = inputs.sigmoid()
    ce_loss = F.binary_cross_entropy_with_logits(inputs, targets, reduction="none")
    loss = ce_loss * (torch.abs(targets - prob) ** gamma)

    if alpha >= 0:
        alpha_t = alpha * (targets > 0.0).float() + (1 - alpha) * (targets <= 0.0).float()
        loss = alpha_t * loss

    return loss.mean(1).sum() / num_boxes


class PostProcess(nn.Module):
    """ 
    åå¤çæ¨¡åï¼å°æ¨¡åçåå§è¾åºè½¬æ¢ä¸ºCOCO APIææçæ ¼å¼
    ä¸»è¦åè½ï¼
    1. å¯¹é¢æµç»æè¿è¡sigmoidæ¿æ´»
    2. éæ©ç½®ä¿¡åº¦æé«çånum_selectä¸ªé¢æµæ¡
    3. å°ç¸å¯¹åæ è½¬æ¢ä¸ºç»å¯¹åæ 
    4. è¿åæ ååçé¢æµç»æå­å¸
    """
    def __init__(self, num_select=300) -> None:
        """
        åå§ååå¤çæ¨¡å
        
        Args:
            num_select (int): éæ©ç½®ä¿¡åº¦æé«çånum_selectä¸ªé¢æµæ¡ï¼é»è®¤300ä¸ª
        """
        super().__init__()
        self.num_select = num_select

    @torch.no_grad()  # æ¨çæ¶ä¸éè¦è®¡ç®æ¢¯åº¦ï¼èçåå­
    def forward(self, outputs, target_sizes):
        """ 
        æ§è¡åå¤çè®¡ç®
        
        Args:
            outputs (dict): æ¨¡åçåå§è¾åºï¼åå«ï¼
                - pred_logits: é¢æµçç±»å«logits [batch_size, num_queries, num_classes]
                - pred_boxes: é¢æµçè¾¹çæ¡åæ  [batch_size, num_queries, 4] (cxcywhæ ¼å¼)
            target_sizes (torch.Tensor): ç®æ å¾åå°ºå¯¸ [batch_size, 2]ï¼åå«æ¯ä¸ªbatchä¸­å¾åçåå§å°ºå¯¸
                - ç¨äºè¯ä¼°æ¶ï¼å¿é¡»æ¯åå§å¾åå°ºå¯¸ï¼æ°æ®å¢å¼ºåï¼
                - ç¨äºå¯è§åæ¶ï¼åºè¯¥æ¯æ°æ®å¢å¼ºåä½paddingåçå¾åå°ºå¯¸
        
        Returns:
            list[dict]: æ¯ä¸ªå¾åçå¤çç»æåè¡¨ï¼æ¯ä¸ªå­å¸åå«ï¼
                - scores: é¢æµç½®ä¿¡åº¦åæ°
                - labels: é¢æµçç±»å«æ ç­¾
                - boxes: é¢æµçè¾¹çæ¡åæ  (xyxyæ ¼å¼)
        """
        # æåæ¨¡åè¾åºçé¢æµlogitsåè¾¹çæ¡
        out_logits, out_bbox = outputs['pred_logits'], outputs['pred_boxes']

        assert len(out_logits) == len(target_sizes)
        assert target_sizes.shape[1] == 2

        # å¯¹é¢æµlogitsè¿è¡sigmoidæ¿æ´»ï¼å¾å°æ¯ä¸ªç±»å«çç½®ä¿¡åº¦æ¦ç
        prob = out_logits.sigmoid()
        
        # éæ©ç½®ä¿¡åº¦æé«çånum_selectä¸ªé¢æµ
        # å°probå±å¹³ä¸º[batch_size, num_queries * num_classes]ï¼ç¶åéæ©top-k
        topk_values, topk_indexes = torch.topk(prob.view(out_logits.shape[0], -1), self.num_select, dim=1)
        scores = topk_values  # ç½®ä¿¡åº¦åæ°
        
        # ä»topk_indexesä¸­è§£ç åºå¯¹åºçæ¥è¯¢ç´¢å¼åç±»å«æ ç­¾
        # topk_boxes: å¯¹åºçæ¥è¯¢ç´¢å¼ (query index)
        # labels: å¯¹åºçç±»å«æ ç­¾ (class label)
        topk_boxes = topk_indexes // out_logits.shape[2]  # æ´é¤å¾å°æ¥è¯¢ç´¢å¼
        labels = topk_indexes % out_logits.shape[2]       # åä½å¾å°ç±»å«æ ç­¾
        
        # å°è¾¹çæ¡ä»ä¸­å¿ç¹æ ¼å¼(cxcywh)è½¬æ¢ä¸ºå·¦ä¸å³ä¸æ ¼å¼(xyxy)
        boxes = box_ops.box_cxcywh_to_xyxy(out_bbox)
        
        # æ ¹æ®topk_boxesç´¢å¼éæ©å¯¹åºçè¾¹çæ¡
        # unsqueeze(-1).repeat(1,1,4)å°ç´¢å¼æ©å±ä¸º[batch_size, num_select, 4]ä»¥å¹éboxesçç»´åº¦
        boxes = torch.gather(boxes, 1, topk_boxes.unsqueeze(-1).repeat(1,1,4))

        # å°ç¸å¯¹åæ [0,1]è½¬æ¢ä¸ºç»å¯¹åæ [0, height/width]
        # ä»target_sizesä¸­æåæ¯ä¸ªå¾åçé«åº¦åå®½åº¦
        img_h, img_w = target_sizes.unbind(1)
        # åå»ºç¼©æ¾å å­å¼ éï¼ç¨äºå°ç¸å¯¹åæ è½¬æ¢ä¸ºç»å¯¹åæ 
        # æ ¼å¼ä¸º[img_w, img_h, img_w, img_h]å¯¹åº[x1, y1, x2, y2]
        scale_fct = torch.stack([img_w, img_h, img_w, img_h], dim=1)
        # åºç¨ç¼©æ¾å å­ï¼å°ç¸å¯¹åæ è½¬æ¢ä¸ºç»å¯¹åæ 
        boxes = boxes * scale_fct[:, None, :]

        # å°ç»æç»ç»æCOCOæ ¼å¼çå­å¸åè¡¨
        # æ¯ä¸ªå­å¸åå«è¯¥å¾åçææé¢æµç»æ
        results = [{'scores': s, 'labels': l, 'boxes': b} for s, l, b in zip(scores, labels, boxes)]

        return results


class MLP(nn.Module):
    """ Very simple multi-layer perceptron (also called FFN)"""

    def __init__(self, input_dim, hidden_dim, output_dim, num_layers):
        super().__init__()
        self.num_layers = num_layers
        h = [hidden_dim] * (num_layers - 1)
        self.layers = nn.ModuleList(nn.Linear(n, k) for n, k in zip([input_dim] + h, h + [output_dim]))

    def forward(self, x):
        for i, layer in enumerate(self.layers):
            x = F.relu(layer(x)) if i < self.num_layers - 1 else layer(x)
        return x


def build_model(args):
    # the `num_classes` naming here is somewhat misleading.
    # it indeed corresponds to `max_obj_id + 1`, where max_obj_id
    # is the maximum id for a class in your dataset. For example,
    # COCO has a max_obj_id of 90, so we pass `num_classes` to be 91.
    # As another example, for a dataset that has a single class with id 1,
    # you should pass `num_classes` to be 2 (max_obj_id + 1).
    # For more details on this, check the following discussion
    # https://github.com/facebookresearch/detr/issues/108#issuecomment-650269223
    num_classes = args.num_classes + 1
    device = torch.device(args.device)


    backbone = build_backbone(
        encoder=args.encoder,
        vit_encoder_num_layers=args.vit_encoder_num_layers,
        pretrained_encoder=args.pretrained_encoder,
        window_block_indexes=args.window_block_indexes,
        drop_path=args.drop_path,
        out_channels=args.hidden_dim,
        out_feature_indexes=args.out_feature_indexes,
        projector_scale=args.projector_scale,
        use_cls_token=args.use_cls_token,
        hidden_dim=args.hidden_dim,
        position_embedding=args.position_embedding,
        freeze_encoder=args.freeze_encoder,
        layer_norm=args.layer_norm,
        target_shape=args.shape if hasattr(args, 'shape') else (args.resolution, args.resolution) if hasattr(args, 'resolution') else (640, 640),
        rms_norm=args.rms_norm,
        backbone_lora=args.backbone_lora,
        force_no_pretrain=args.force_no_pretrain,
        gradient_checkpointing=args.gradient_checkpointing,
        load_dinov2_weights=args.pretrain_weights is None,
    )
    if args.encoder_only:
        return backbone[0].encoder, None, None
    if args.backbone_only:
        return backbone, None, None

    args.num_feature_levels = len(args.projector_scale)
    transformer = build_transformer(args)

    model = LWDETR(
        backbone,
        transformer,
        num_classes=num_classes,
        num_queries=args.num_queries,
        aux_loss=args.aux_loss,
        group_detr=args.group_detr,
        two_stage=args.two_stage,
        lite_refpoint_refine=args.lite_refpoint_refine,
        bbox_reparam=args.bbox_reparam,
    )
    return model

def build_criterion_and_postprocessors(args):
    device = torch.device(args.device)
    matcher = build_matcher(args)
    weight_dict = {'loss_ce': args.cls_loss_coef, 'loss_bbox': args.bbox_loss_coef}
    weight_dict['loss_giou'] = args.giou_loss_coef
    # TODO this is a hack
    if args.aux_loss:
        aux_weight_dict = {}
        for i in range(args.dec_layers - 1):
            aux_weight_dict.update({k + f'_{i}': v for k, v in weight_dict.items()})
        if args.two_stage:
            aux_weight_dict.update({k + f'_enc': v for k, v in weight_dict.items()})
        weight_dict.update(aux_weight_dict)

    losses = ['labels', 'boxes', 'cardinality']

    try:
        sum_group_losses = args.sum_group_losses
    except:
        sum_group_losses = False
    criterion = SetCriterion(args.num_classes + 1, matcher=matcher, weight_dict=weight_dict,
                             focal_alpha=args.focal_alpha, losses=losses, 
                             group_detr=args.group_detr, sum_group_losses=sum_group_losses,
                             use_varifocal_loss = args.use_varifocal_loss,
                             use_position_supervised_loss=args.use_position_supervised_loss,
                             ia_bce_loss=args.ia_bce_loss)
    criterion.to(device)
    postprocessors = {'bbox': PostProcess(num_select=args.num_select)}

    return criterion, postprocessors
